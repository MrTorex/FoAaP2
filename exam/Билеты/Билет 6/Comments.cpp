#include <iostream>

// Структура для элемента двунаправленной очереди
struct spis2
{
	int info;       // Информационное поле элемента
	spis2* prev = nullptr;  // Указатель на предыдущий элемент
	spis2* next = nullptr;  // Указатель на следующий элемент
};

// Функция проверки пустоты очереди
bool is_empty(spis2* begin, spis2* end)
{
	return begin == nullptr && end == nullptr;  // Возвращает true, если начало и конец равны nullptr
}

// Функция добавления элемента в начало очереди
void add_begin(spis2*& begin, spis2*& end, int add)
{
	spis2* new_el = new spis2;  // Создание нового элемента
	new_el->info = add;         // Запись информации в новый элемент

	if (is_empty(begin, end))   // Если очередь пуста
	{
		begin = new_el;         // Начало и конец очереди указывают на новый элемент
		end = new_el;
	}
	else  // Если очередь не пуста
	{
		new_el->next = begin;   // Устанавливаем связь нового элемента с текущим началом
		begin->prev = new_el;   // Устанавливаем связь текущего начала с новым элементом
		begin = new_el;         // Новый элемент становится началом очереди
	}
}

// Функция добавления элемента в конец очереди
void add_end(spis2*& begin, spis2*& end, int add)
{
	spis2* new_el = new spis2;  // Создание нового элемента
	new_el->info = add;         // Запись информации в новый элемент

	if (is_empty(begin, end))   // Если очередь пуста
	{
		begin = new_el;         // Начало и конец очереди указывают на новый элемент
		end = new_el;
	}
	else  // Если очередь не пуста
	{
		new_el->prev = end;     // Устанавливаем связь нового элемента с текущим концом
		end->next = new_el;     // Устанавливаем связь текущего конца с новым элементом
		end = new_el;           // Новый элемент становится концом очереди
	}
}

// Функция печати очереди, начиная с начала
void print_begin(spis2* begin)
{
	spis2* t = begin;  // Временный указатель на начало очереди

	while (t)  // Пока не достигнут конец очереди (t не nullptr)
	{
		std::cout << t->info << ' ';  // Выводим информацию текущего элемента
		t = t->next;                  // Переходим к следующему элементу
	}
}

// Функция печати очереди, начиная с конца
void print_end(spis2* end)
{
	spis2* t = end;  // Временный указатель на конец очереди

	while (t)  // Пока не достигнут начало очереди (t не nullptr)
	{
		std::cout << t->info << ' ';  // Выводим информацию текущего элемента
		t = t->prev;                  // Переходим к предыдущему элементу
	}
}

// Функция очистки памяти, выделенной под элементы очереди
void clear(spis2*& begin, spis2*& end)
{
	while (begin)  // Пока очередь не пуста (begin не nullptr)
	{
		if (is_empty(begin, end))  // Если очередь уже пуста
			return;

		if (begin == end)  // Если в очереди остался один элемент
		{
			delete begin;  // Освобождаем память
			begin = nullptr;  // Указатели на начало и конец очереди делаем nullptr
			end = nullptr;
		}
		else  // Если в очереди более одного элемента
		{
			spis2* t = begin;     // Временный указатель на начало
			begin = begin->next;  // Сдвигаем начало на следующий элемент
			begin->prev = nullptr;  // Устанавливаем связь нового начала с nullptr (новый начало)
			delete t;  // Освобождаем память старого начала
		}
	}
}

int main()
{
	spis2* begin1 = nullptr, * end1 = nullptr, * begin2 = nullptr, * end2 = nullptr;  // Инициализация указателей на начало и конец двух очередей
	int size = 7;  // Переменная для размера очереди

	for (int i = 0; i < size; i++)  // Цикл для ввода элементов в первую очередь
	{
		int add;
		std::cin >> add;
		add_begin(begin1, end1, add);  // Добавление элемента в начало первой очереди
	}

	print_begin(begin1);  // Вывод первой очереди с начала
	std::cout << '\n';

	spis2* t = begin1->next;  // Указатель на второй элемент первой очереди

	for (int i = 1; i < size; i += 2)  // Цикл для переноса каждого второго элемента во вторую очередь
	{
		add_begin(begin2, end2, t->info);  // Добавление второго элемента в начало второй очереди
		t = t->next->next;  // Переход к следующему через один элементу в первой очереди
	}

	print_begin(begin2);  // Вывод второй очереди с начала

	clear(begin1, end1);  // Очистка памяти первой очереди
	clear(begin2, end2);  // Очистка памяти второй очереди

	return 0;  // Возврат из функции main
}
