#include <iostream>

// Определение структуры для элемента стека
struct stack
{
	int info;            // Информационное поле элемента
	stack* next = nullptr;  // Указатель на следующий элемент в стеке
};

// Функция проверки пустоты стека
bool is_empty(stack* top)
{
	return top == nullptr;  // Возвращает true, если вершина стека равна nullptr
}

// Функция добавления элемента в стек
void add(stack*& top, int add)
{
	if (is_empty(top))  // Если стек пуст
	{
		top = new stack;   // Выделяем память под новый элемент
		top->info = add;   // Записываем значение в информационное поле
	}
	else  // Если стек не пуст
	{
		stack* t = top;    // Временный указатель на текущий top стека
		top = new stack;   // Выделяем память под новый элемент
		top->info = add;   // Записываем значение в информационное поле нового элемента
		top->next = t;     // Устанавливаем связь нового элемента с предыдущим top стека
	}
}

// Функция печати элементов стека
void print(stack* top)
{
	stack* t = top;  // Временный указатель на вершину стека

	while (t)  // Пока не достигнут конец стека (t не nullptr)
	{
		std::cout << t->info << ' ';  // Выводим информацию текущего элемента
		t = t->next;                  // Переходим к следующему элементу в стеке
	}
}

// Функция выполнения задания: меняет местами минимальный и максимальный элементы в стеке
void task(stack*& top)
{
	if (top == nullptr || top->next == nullptr)
		return;  // Если стек пуст или содержит только один элемент, выходим

	stack* max = top, * min = top, * t = top, * min_prev = nullptr, * max_prev = nullptr, * prev = nullptr;
	int max_val = top->info, min_val = top->info;

	while (t)  // Проходим по всем элементам стека
	{
		if (t->info > max_val)  // Если текущий элемент больше максимального
		{
			max_prev = prev;  // Запоминаем предыдущий элемент перед максимальным
			max = t;          // Запоминаем текущий элемент как новый максимальный
			max_val = t->info; // Обновляем значение максимального элемента
		}
		if (t->info < min_val)  // Если текущий элемент меньше минимального
		{
			min_prev = prev;  // Запоминаем предыдущий элемент перед минимальным
			min = t;          // Запоминаем текущий элемент как новый минимальный
			min_val = t->info; // Обновляем значение минимального элемента
		}
		prev = t;  // Переходим к следующему элементу в стеке
		t = t->next;
	}

	if (min != max)  // Если минимальный и максимальный элементы различны
	{
		if (min_prev)  // Если минимальный элемент не находится в начале стека
			min_prev->next = max;  // Устанавливаем связь предыдущего элемента минимального с максимальным
		else
			top = max;  // Если минимальный элемент в начале стека, обновляем указатель top

		if (max_prev)  // Если максимальный элемент не находится в начале стека
			max_prev->next = min;  // Устанавливаем связь предыдущего элемента максимального с минимальным
		else
			top = min;  // Если максимальный элемент в начале стека, обновляем указатель top

		stack* temp = min->next;  // Временная переменная для сохранения указателя на следующий элемент минимального
		min->next = max->next;    // Устанавливаем связь минимального элемента с элементом, идущим после максимального
		max->next = temp;         // Устанавливаем связь максимального элемента с элементом, идущим после минимального
	}
}

// Функция очистки памяти, выделенной под элементы стека
void clear(stack* top)
{
	if (is_empty(top))  // Если стек пуст, выходим из функции
		return;

	if (!top->next)  // Если в стеке остался только один элемент
	{
		delete top;  // Освобождаем память, выделенную под этот элемент
		return;
	}

	stack* t = top;  // Временный указатель на вершину стека
	while (t)  // Пока не достигнут конец стека
	{
		top = top->next;  // Переходим к следующему элементу в стеке
		delete t;         // Освобождаем память, выделенную под текущий элемент
		t = top;          // Обновляем временный указатель на вершину стека
	}
}

int main()
{
	stack* top = nullptr;  // Инициализация указателя на вершину стека
	int size = 7;           // Размер стека

	for (int i = 0; i < size; i++)  // Цикл для добавления элементов в стек
	{
		int value;
		std::cin >> value;  // Ввод элемента
		add(top, value);    // Добавление элемента в стек
	}

	print(top);  // Печать элементов стека до выполнения задания
	task(top);   // Выполнение задания: меняем местами первый и максимальный элементы в стеке
	std::cout << '\n';
	print(top);  // Печать элементов стека после выполнения задания
	clear(top);  // Очистка памяти, выделенной под элементы стека

	return 0;  // Возврат из функции main
}
