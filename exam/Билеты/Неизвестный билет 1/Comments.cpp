#include <iostream>

// Определение структуры для элемента двунаправленной очереди
struct spis2
{
	char info;            // Информационное поле элемента (символ)
	spis2* prev = nullptr, * next = nullptr;  // Указатели на предыдущий и следующий элементы
};

// Функция проверки пустоты очереди
bool is_empty(spis2* begin, spis2* end)
{
	return begin == nullptr && end == nullptr;  // Возвращает true, если начало и конец очереди равны nullptr
}

// Функция добавления элемента в начало очереди
void add_begin(spis2*& begin, spis2*& end, char add)
{
	spis2* new_el = new spis2;  // Выделяем память под новый элемент
	new_el->info = add;         // Записываем символ в информационное поле нового элемента

	if (is_empty(begin, end))   // Если очередь пуста
	{
		begin = new_el;    // Начало очереди указывает на новый элемент
		end = new_el;      // Конец очереди указывает на новый элемент
	}
	else
	{
		new_el->next = begin;    // Устанавливаем связь нового элемента с текущим началом очереди
		begin->prev = new_el;    // Устанавливаем связь текущего начала очереди с новым элементом
		begin = new_el;          // Обновляем указатель на начало очереди
	}
}

// Функция добавления элемента в конец очереди
void add_end(spis2*& begin, spis2*& end, char add)
{
	spis2* new_el = new spis2;  // Выделяем память под новый элемент
	new_el->info = add;         // Записываем символ в информационное поле нового элемента

	if (is_empty(begin, end))   // Если очередь пуста
	{
		begin = new_el;    // Начало очереди указывает на новый элемент
		end = new_el;      // Конец очереди указывает на новый элемент
	}
	else
	{
		new_el->prev = end;      // Устанавливаем связь нового элемента с текущим концом очереди
		end->next = new_el;      // Устанавливаем связь текущего конца очереди с новым элементом
		end = new_el;            // Обновляем указатель на конец очереди
	}
}

// Функция печати элементов очереди, начиная с начала
void print_begin(spis2* begin)
{
	spis2* t = begin;  // Временный указатель на начало очереди

	while (t)  // Пока не достигнут конец очереди (t не nullptr)
	{
		std::cout << t->info << ' ';  // Выводим символ текущего элемента
		t = t->next;                  // Переходим к следующему элементу в очереди
	}
}

// Функция печати элементов очереди, начиная с конца
void print_end(spis2* end)
{
	spis2* t = end;  // Временный указатель на конец очереди

	while (t)  // Пока не достигнут начало очереди (t не nullptr)
	{
		std::cout << t->info << ' ';  // Выводим символ текущего элемента
		t = t->prev;                  // Переходим к предыдущему элементу в очереди
	}
}

// Функция освобождения памяти, выделенной под элементы очереди
void clear(spis2*& begin, spis2*& end)
{
	while (begin)  // Пока очередь не пуста
	{
		if (is_empty(begin, end))  // Если очередь пуста, выходим из функции
			return;

		if (begin == end)  // Если в очереди остался только один элемент
		{
			delete begin;  // Освобождаем память, выделенную под этот элемент
			begin = nullptr;
			end = nullptr;
		}
		else  // Если в очереди больше одного элемента
		{
			spis2* t = begin;     // Временный указатель на начало очереди
			begin = begin->next;  // Переходим к следующему элементу в очереди
			begin->prev = nullptr;  // Обнуляем указатель prev у нового начала очереди
			delete t;             // Освобождаем память, выделенную под предыдущий начальный элемент
		}
	}
}

int main()
{
	spis2* begin = nullptr, * end = nullptr;  // Инициализация указателей на начало и конец очереди
	int size = 9;  // Размер очереди

	for (int i = 0; i < size; i++)  // Цикл для добавления символов в очередь
	{
		char c;
		std::cin >> c;  // Ввод символа
		add_begin(begin, end, c);  // Добавление символа в начало очереди
	}

	print_begin(begin);  // Печать элементов очереди с начала
	add_end(begin, end, 'w');  // Добавление символа 'w' в конец очереди
	std::cout << '\n';
	print_begin(begin);  // Печать элементов очереди с начала
	clear(begin, end);   // Освобождение памяти, выделенной под элементы очереди

	return 0;  // Возврат из функции main
}
